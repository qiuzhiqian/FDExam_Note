# 系统开发方法

[toc]

## 软件开发方法

### 软件开发方法

1. **结构化方法**：用户至上，严格区分工作阶段，系统开发过程工程化。

   缺点：面向过程，比较死板

2. **原型法**：适合需求不明确的开发

3. **面向对象方法**：更好的复用性，关键在于建立一个全面、合理、统一的模型

4. **面向服务的方法**：SO方法有三个主要的抽象级别：操作、服务、业务流程

   SOAD有三个层次：基础设计层、应用结构层、业务组织层

   服务建模：分为服务发现、服务规约、服务实现

### UML图[21]
UML 由构造块、公共机制和架构三个部分组成。

大体上可以分为两类图：
- 静态图(结构图)
   - 类图
   - 对象图
   - 构件图
   - 部署图
   - 制品图
   - 包图
   - 组合结构图
- 动态图(行为图)
   - 用例图
   - 顺序图
   - 通信图(协作图)
   - 状态图
   - 活动图
   - 定时图
   - 交互概览图

### 软件开发模型[16]

1. **瀑布模型**：瀑布模型是最早使用的软件生存周期模型之一。瀑布模型的特点是因果关系紧密相连，前一个阶段工作的结果是后一个阶段工作的输入。或者说，每一个阶段都是建立在前一个阶段的正确结果之上，前一个阶段的错误和疏漏会隐蔽地带入后一个阶段。这种错误有时甚至可能是灾难性的，因此每一个阶段工作完成后，都要进行审查和确认。适合于需求明确的项目。
2. 演化模型：快速应用开发
3. 增量模型：构建组装模型/给予构建的开发方法
4. **原型模型**：敏捷开发方法。抛弃型原型&演化型原型。
5. **螺旋模型**：在快速模型的基础上扩展而成。螺旋模型将整个软件开发过程分为多个阶段，每个阶段都由目标设定、**风险分析**、开发和有效性验证以及评审4个部分组成。螺旋模型=原型模型+瀑布模型。
6. 喷泉模型：模型驱动的开发方法
7. V模型：基于架构的开发方法。强调测试重要性。
8. 快速应用开发：瀑布模型+给予构件的开发。



### 逆向工程

- 实现级：包括程序的**抽象语法树**、符号表、过程的设计表示。
- 结构级：包括反映**程序分量之间相互依赖关系**的信息，例如调用图、结构图、程序和数据结构。
- 功能级：包括反映程序段功能及程序段之间关系的信息，例如数据和控制流模型。
- 领域级：包括反映程序分量或程序诸实体与应用领域概念之间对应关系的信息，例如实体关系模型。

软件的逆向工程就是分析已有的程序，寻求比源代码更高级的抽象表现形式。一般认为，凡是在软件生命周期内将软件某种形式的描述转换成更为抽象形式的活动都可称为逆向工程。与之相关的概念是：

1. 重构（restructuring），指在同一抽象级别上转换系统描述形式；
2. 设计恢复（design recovery），指借助工具从已有程序中抽象出有关数据设计、总体结构设计和过程设计的信息（不一定是原设计）；
3. 再工程（re-engineering），也称修复和改造工程，它是在逆向工程所获信息的基础上修改或重构已有的系统，产生系统的一个新版本。

### 净室软件工程

- 净室即无尘室、洁净室，也就是一个受控污染级别的环境。



## 敏捷开发方法[16、14]

​	敏捷方法是从20世纪90年代开始逐渐引起广泛关注的一些新型软件开发方法，以应对快速变化的需求。敏捷方法的核心思想主要有以下三点。

1. 敏捷方法是“适应性”而非“预设性”的。传统方法试图对一个软件开发项目在很长的时间跨度内做出详细的计划，然后依计划进行开发。这类方法在计划制定完成后拒绝变化。而敏捷方法则欢迎变化，其实它的目的就是成为适应变化的过程，甚至能允许改变自身来适应变化。

2. 敏捷方法是以人为本，而不是以过程为本。传统方法以过程为本，强调充分发挥人的特性，不去限制它，并且软件开发在无过程控制和过于严格繁琐的过程控制中取得一种平衡，以保证软件的质量。

3. 迭代增量式的开发过程。敏捷方法以原型开发思想为基础，采用迭代增量式开发，发行版本小型化。

敏捷开发方法有

1. XP极限编程：它源于Smalltalk圈子，特别是Kent Beck和Ward Cunningham在20世纪80年代末的密切合作。XP在一些对费用控制严格的公司中的使用，已经被证明是非常有效的。
2. Cockburn水晶系列方法：与XP的高度纪律性不同，Alistair探索了用最少纪律约束而仍能成功的方法，从而在产出效率与易于运作上达到一种平衡。也就是说，虽然水晶系列不如XP那样的产出效率，但会有更多的人能够接受并遵循它。
3. 开放式源码：开放式源码项目有一个特别之处，就是程序开发人员在地域上分布很广。
4. SCRUM：该方法强调这样一个事实，即明确定义了的可重复的方法过程只限于在明确定义了的可重复的环境中，为明确定义了的可重复的人员所用，去解决明确定义了的可重复的问题。
5. Coad的功用驱动开发方法FDD：在FDD中，一个迭代周期一般是两周。在FDD中，编程开发人员分成两类：**首席程序员**和**“类”程序员(class owner)**。首席程序员是最富有经验的开发人员，他们是项目的协调者、设计者和指导者，而“类”程序员则主要做源码编写。
6. ASD：ASD （Adaptive Software Development）方法由Jim Highsmith提出，其核心是三个非线性的、重叠的开发阶段：**猜测、合作与学习**。





## 需求工程

### 需求获取

软件需求是指用户对系统在功能、行为、性能、设计约束等方面的期望。需求可以分为业务需求、用户需求和系统需求。

### 需求分析

## 软件系统工具[16]

1. 软件开发工具：
2. 设计工具：
3. 编码与排错工具：
4. **软件维护工具**：如版本控制工具
5. 软件管理和软件支持工具：如版本管理工具和版本评价工具



## 软件重用的基础知识[16]

软件重用是指在两次或多次不同的软件开发过程中重复使用相同或相似软件元素的过程。

软件元素包括程序代码、测试用例、设计文档、设计过程、需求分析文档甚至领域知识。



## 面向构件的编程[16][21]

基于一般OOP风格，面向构件的编程需要下列基本的支持：**多态性**(可替代性)、**模块封装性**(高层次信息的隐藏)、**后期的绑定和装载**(部署独立性)和**安全性**(类型和模块安全性)。

软件构件是部署、版本控制和替换的基本单位。构件是一组通常需要同时部署的原子构件。原子构件通常成组地部署，但是它也能够被单独部署。构件与原子构件的区别在于，大多数原子构件永远都不会被单独部署，尽管它们可以被单独部署。大多数原子构件都属于一个构件家族，一次部署往往涉及整个家族。一个模块是不带单独资源的原子构件。

构件的特点：
- 独立部署单元
- 作为第三方的组装单元
- 没有(外部的)可见状态

基于构件的开发模型由软件的需求分析定义、**体系结构设计**、**构件库建立**、**应用软件构建**以及测试和发布5个阶段组成。

### 构件标准

- COBRA
- COM
- EJB

#### COM[21]
COM支持两种形式的对象组装，包含(Containment)和聚集(Aggregation)
- 包含是一个对象拥有指向另一个对象的唯一引用。外部对象只是把请求转发给内部对象，所谓转发，就是调用内部对象的方法。
- 聚集直接把内部对象接口引用传递给外部对象的客户，而不是再转发请求。










### 软件系统建模



## 系统设计
### 界面设计
### 结构化设计[21]
- 抽象化
- 自顶而下，逐步求精
- 信息屏蔽
- 模块独立(高类聚、低耦合)
#### 内聚
功能内聚 > 顺序内聚 > 通信内聚 > 过程内聚 > 瞬时内聚（时间内聚）> 逻辑内聚 > 偶然内聚｛巧合内聚）

#### 耦合
非直接揭合 > 数据藕合 > 标记箱合 > 控制擂台 > 外部捐合 > 公共耦合 > 内部耦合

### 面向对象设计


### 测试与评审
#### 白盒测试
白盒测试，又称结构测试，主要用于单元测试阶段。它的前提是可以把程序看成装在一个透明的白箱子里，测试者完全知道程序的结构和处理算法。这种方法按照程序内部逻辑设计测试用例，检测程序中的主要执行通路是否都能按预定要求正常工作。

白盒测试根据软件的内部逻辑设计测试用例，常用的技术是逻辑覆盖，即考察用测试数据运行被测程序时对程序逻辑的覆盖程度。
主要的覆盖标准有 6 种：
- 语句覆盖
- 判定覆盖、
- 条件覆盖
- 判定/条件覆盖
- 组合条件覆盖
- 路径覆盖。

##### McCabe度量法[21]
McCabe度量法是一种基于程序控制流的复杂性度量方法。
McCabe复杂性度量又称环路度量,其计算公式为: V(g)=m-n+2,其中m和n分别代表图中的边数和顶点数。

#### 黑盒测试

### 系统运行与软件维护

